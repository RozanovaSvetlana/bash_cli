# Архитектура CLI интерпретатора

Программа представляет собой интерпретатор командной строки. Интерпретатор построчно до символа новой строки считывает команды пользователя и выполняет их. Программа работает с графическими символами ASCII. При использовании программы с символами из других кодировок ее поведение не определено.  

Подробнее о командах, введенных пользователем, и примерах их использования см. ниже. 

Потоки ввода-вывода всей программы задаются в ее аргументах при запуске. Если они не заданы, то потоки ввода-вывода берутся по умолчанию: `stdin`, `stdout`, `stderr`. 

## 1. Главный цикл

[Картинка с конечным автоматом цикла]

Основной принцип работы программы построен на главном цикле, состоящем из следующих этапов:
1. Ввод пользователем строки с командами.
2. Лексическая обработка - обработка одинарных и двойных кавычек, разбиение пайплайна на последовательность команд, подстановка переменных.
3. Парсинг - разбиение каждой команды на слова.
4. Выполнение команд. 

_Команда_ - введенная пользователем строка, разделенная пайпами. У команды есть ее имя и аргументы, представляющие собой строки. Что является пайпом, а что просто символом `|` см. ниже в описании этапа лексической обработки. 

Определение термина _слово_ см. в описании этапа парсинга.

### 1.1. Ввод строки пользователя
1. Вывод приглашения пользователя на ввод `> `.
2. Считывание строки символов до символа переноса строки.

### 1.2. Lexer - разделение ввода по символам `|` и осуществление подстановок

Подстановка: `$имя_переменной`, где `имя_переменной` - `w+` (непустая последовательность букв (по умолчанию латинский алфавит) или цифр).

`input`: `string` - строка (ввод пользователя) \
`output`: `vector<string>` - вектор строк (каждая строка отдельная команда, вместе - последовательность команд).

Lexer последовательно проходит по `input`, записывает пройденные символы в `buffer` - текущая прочитанная строка.

#### Состояния Lexer'а: 

[Картинка с конечным автоматом лексера]

- `Start`, начальное состояние;
- `Single quote (SQ)`, открыта одинарная кавычка;
- `Double quote (DQ)`, открыта двойная кавычка;
- `BS`, предыдущий символ `\` - символ экранирования (любой другой символ после него теряет свой синтаксический смысл).
- `Dollar`, началась подстановка;
- `Dollar in Double quote (Dollar & DQ)`, началась подстановка внутри двойных кавычек;
- `BS in Double quote (BS & DQ)`, предыдущий символ `\` в двойных кавычках.

#### Состояние `Start`.
- Если встретили '|', то совершаем следующее действие: добавляем `buffer` в `output` (без `|`), очищаем `buffer`, остаёмся в этом же состоянии.
- Символ `'` - переход в `SQ`.
- Символ `"` - переход в `DQ`.
- Символ `\` - переход в `BS`.
- Символ `$` - переход в `Dollar`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `SQ`.
- Если встретили символ `'`, то переходим в `Start`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `DQ`.
- Если встретили символ `"`, то переходим в `Start`.
- Символ `$` - переход в `Dollar & DQ`.
- Символ `\` - переход в `BS & DQ`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `BS`.
- Любой символ - переходим в `Start`.

#### Состояние `Dollar`.
В этом состоянии записываем пройденные символы не в `buffer`, а в `var` (`$` никуда не записываем).
- Если встретили `w` (буква или цифра) - остаёмся в этом же состоянии.
- Любой другой символ - если `var` пустая строка, то записываем в `buffer` символ `$`, иначе записываем в `buffer` строку `varEnv[var]` (значение переменной `var` хранящееся в окружении; операцией присваивания должно гарантироваться, что в этом значении все символы, имеющие синтаксический смысл, экранированы символом `\`), очищаем `var`. 
В любом случае после этих действий переходим в `Start`, при этом продолжаем чтение с того же символа (не двигаемся по `input`).

#### Состояние `Dollar & DQ`.
Это состояние аналогично состоянию `Dollar`, только переходим не в `Start`, а в `DQ`.

#### Состояние `BS & DQ`.
Это состояние аналогично состоянию `BS`, только переходим не в `Start`, а в `DQ`.

#### Конечных состояний два (когда прочитали весь `input`):
- `Start` - добавляем `buffer` в `output`, возвращаем `output`.
- `Dollar` - совершаем действие, как если бы встретили любой символ кроме `w`.

Если строка закончилась в любом другом состоянии, то !ошибка разбиения по `|`!.

Пример валидного `input`: \
`   ` \
`echo a` \
`echo '"' | echo b "'"` \
`echo \| | echo \'` \

Пример невалидного `input`: \
`echo "a | echo b` \
`echo 'abc` \
`echo \`

### 1.3. Parser - разбиение команды на слова

[Картинка с конечным автоматом парсера]

Слово - это последовательность непробельных символов (`s`), или последовательность символов, заключённых в кавычки, или экранированный пробельный символ (`\ `), или комбинация этих последовательностей (кавычки удаляются из строки). 
Первое слово - имя команды, следующие - её аргументы. 
За исключением команды присваивания, которая имеет вид `w+=*`, имя команды в таком случае - это символ `=`, первый аргумент `w+` (последовательность букв или цифр левее `=`, имя переменной), второй аргумент `*` (всё, что правее `=`, значение переменной).

`input` - `vector<string>` - вектор строк (команд). \
`output` - массив структур `msg` с полями: `string name` - имя команды, `vector<string> args` - аргументы команды.

Parser последовательно проходится по каждой строке `input` и записывает пройденные символы в `buffer`.

#### Состояния Parser'а:
- `Empty` - начальное состояние, слово ещё не началось.
- `Var word (VW)` - началось слово, которое может быть именем переменной.
- `Regular word (RW)` - началось обычное слово.
- `Single quote (SQ)` - открыта одинарная кавычка.
- `Double quote (DQ)` - открыта двойная кавычка.
- `BS` - предыдущий символ `\`.
- `BS in Double quote (BS & DQ)` - предыдущий символ `\` в двойных кавычках.

#### Состояние `Empty`:
- Если встретили пробельный символ (`s`), то остаёмся в этом же состоянии, не записываем в `buffer` этот символ.
- Если встретили букву или цифру (`w`) и это первое слово в этой команде, то переходим в состояние `VW`.
- Любой другой символ - переходим в состояние `RW`.

#### Состояние `VW`:
- Если встретили букву или цифру (`w`), то остаёмся в этом же состоянии.
- Символ `=` - записываем в `name` символ `=`, добавляем в `args` строку `buffer`, потом строку из всего, что после текущего символа, завершаем разбор текущей команды.
- Любой другой символ - переходим в состояние `RW`, не записываем в `buffer` этот символ, продолжаем чтение с него же.

#### Состояние `RW`:
- Если встретили пробельный символ, то если это первое слово, то в `name` записываем `buffer`, иначе добавляем в `args` строку `buffer`.
В любом случае отчищаем `buffer`, переходим в состояние `Empty`.
- Символ `'` - не добавляем в `buffer`, переход в `SQ`.
- Символ `"` - не добавляем в `buffer`, переход в `DQ`.
- Символ `\` - не добавляем в `buffer`, переход в `BS`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `SQ`.
- Если встретили символ `'`, не добавляем его в `buffer`, переходим в `RW`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `DQ`.
- Если встретили символ `"`, то не добавляем его в `buffer`, переходим в `RW`.
- Символ `\` - не добавляем в `buffer`, переход в `BS & DQ`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `BS`.
- Любой символ - переходим в `RW`.

#### Состояние `BS & DQ`.
- Любой символ - переходим в `DQ`.

#### Конечные состояния (когда прочитали весь всю строку):
- `RW` - Совершаем действие, как если бы встретили пробельный символ.
- `Empty` - заканчиваем разбор команды.

Если строка закончилась в любом другом состоянии, то !ошибка разбиения на команды!.



# Фаза 1 

Лексер не обрабатывает пайпы `|`, считает что в полученной строке только одна команда. \
Подстановки и операция присваивания не обрабатываются, выполняются только именные внутренние команды и вызываются внешние программы.

# Фаза 2

Полная функциональность в соответстии с ТЗ.
