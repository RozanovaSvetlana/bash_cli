# CLI bash-like интерпретатор

Программа представляет собой интерпретатор командной строки. Интерпретатор построчно до символа новой строки считывает команды пользователя и выполняет их. Программа работает с графическими символами ASCII. При использовании программы с символами из других кодировок ее поведение не определено.  

Подробнее о командах, введенных пользователем, и примерах их использования см. ниже. 

Потоки ввода-вывода всей программы задаются в ее аргументах при запуске. Если они не заданы, то потоки ввода-вывода берутся по умолчанию: `stdin`, `stdout`, `stderr`. 

## 1. Главный цикл

![](./circleDiagram.svg)

Основной принцип работы программы построен на главном цикле, состоящем из следующих этапов:
1. Ввод пользователем строки с командами.
2. Лексическая обработка - обработка одинарных и двойных кавычек, разбиение пайплайна на последовательность команд, подстановка переменных.
3. Парсинг - разбиение каждой команды на слова.
4. Выполнение команд. 

_Команда_ - введенная пользователем строка, разделенная пайпами. У команды есть ее имя и аргументы, представляющие собой строки. Что является пайпом, а что просто символом `|` см. ниже в описании этапа лексической обработки. 

Определение термина _слово_ см. в описании этапа парсинга.

### 1.1. Ввод строки пользователя
1. Вывод приглашения пользователя на ввод `> `.
2. Считывание строки символов до символа переноса строки.

### 1.2. Lexer - разделение ввода по символам `|` и осуществление подстановок

Подстановка: `$имя_переменной`, где `имя_переменной` - `w+` (непустая последовательность букв (по умолчанию латинский алфавит) или цифр).

`input`: `string` - строка (ввод пользователя) \
`output`: `vector<string>` - вектор строк (каждая строка отдельная команда, вместе - последовательность команд).

Lexer последовательно проходит по `input`, записывает пройденные символы в `buffer` - текущая прочитанная строка.

#### Состояния Lexer'а: 

![](./lexerDiagram.svg)

- `Start`, начальное состояние;
- `Single quote (SQ)`, открыта одинарная кавычка;
- `Double quote (DQ)`, открыта двойная кавычка;
- `BS`, предыдущий символ `\` - символ экранирования (любой другой символ после него теряет свой синтаксический смысл).
- `Dollar`, началась подстановка;
- `Dollar in Double quote (Dollar & DQ)`, началась подстановка внутри двойных кавычек;
- `BS in Double quote (BS & DQ)`, предыдущий символ `\` в двойных кавычках.

#### Состояние `Start`.
- Если встретили '|', то совершаем следующее действие: добавляем `buffer` в `output` (без `|`), очищаем `buffer`, остаёмся в этом же состоянии.
- Символ `'` - переход в `SQ`.
- Символ `"` - переход в `DQ`.
- Символ `\` - переход в `BS`.
- Символ `$` - не записываем в `buffer`, переход в `Dollar`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `SQ`.
- Если встретили символ `'`, то переходим в `Start`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `DQ`.
- Если встретили символ `"`, то переходим в `Start`.
- Символ `$` - не записываем в `buffer`, переход в `Dollar & DQ`.
- Символ `\` - переход в `BS & DQ`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `BS`.
- Любой символ - переходим в `Start`.

#### Состояние `Dollar`.
В этом состоянии записываем пройденные символы не в `buffer`, а в `var`.
- Если встретили `w` (буква или цифра) - остаёмся в этом же состоянии.
- Любой другой символ - если `var` пустая строка, то записываем в `buffer` символ `$`, иначе записываем в `buffer` строку `varEnv[var]` (значение переменной `var` хранящееся в окружении; операцией присваивания должно гарантироваться, что в этом значении все символы, имеющие синтаксический смысл, экранированы символом `\`), очищаем `var`. \
  Если в `varEnv` не найдено значение по ключу `var`, то в `buffer` ничего не пишется, оставляя его пустым (произойдет пустая подстановка). \
  В любом случае после этих действий переходим в `Start`, при этом продолжаем чтение с того же символа (не двигаемся по `input`).

#### Состояние `Dollar & DQ`.
Это состояние аналогично состоянию `Dollar`, только переходим не в `Start`, а в `DQ`.

#### Состояние `BS & DQ`.
Это состояние аналогично состоянию `BS`, только переходим не в `Start`, а в `DQ`.

#### Конечных состояний два (когда прочитали весь `input`):
- `Start` - добавляем `buffer` в `output`, возвращаем `output`.
- `Dollar` - совершаем действие, как если бы встретили любой символ кроме `w`.

Если строка закончилась в любом другом состоянии, то !ошибка разбиения по `|`!.

Пример валидного `input`: \
`   ` \
`echo a` \
`echo '"' | echo b "'"` \
`echo \| | echo \'` \

Пример невалидного `input`: \
`echo "a | echo b` \
`echo 'abc` \
`echo \`

### 1.3. Parser - разбиение команды на слова

![](./parserDiagram.svg)

Слово - это последовательность непробельных символов (`s`), или последовательность символов, заключённых в кавычки, или экранированный пробельный символ (`\ `), или комбинация этих последовательностей (внешние кавычки и экранирование удаляются из последовательности). 
Первое слово - имя команды, следующие - её аргументы. 
За исключением команды присваивания, которая имеет вид `w+=*`, имя команды в таком случае - это символ `=`, первый аргумент `w+` (последовательность букв или цифр левее `=`, имя переменной), второй аргумент `*` (всё, что правее `=`, значение переменной).

`input` - `vector<string>` - вектор строк (команд). \
`output` - `vector` структур `job` с полями: `string name` - имя команды, `vector<string> args` - аргументы команды.

Parser последовательно проходится по каждой строке `input` и записывает пройденные символы в `buffer`.

#### Состояния Parser'а:
- `Empty` - начальное состояние, слово ещё не началось.
- `Var word (VW)` - началось слово, которое может быть именем переменной.
- `Regular word (RW)` - началось обычное слово.
- `Single quote (SQ)` - открыта одинарная кавычка.
- `Double quote (DQ)` - открыта двойная кавычка.
- `BS` - предыдущий символ `\`.
- `BS in Double quote (BS & DQ)` - предыдущий символ `\` в двойных кавычках.

#### Состояние `Empty`:
- Если встретили пробельный символ (`s`), то остаёмся в этом же состоянии, не записываем в `buffer` этот символ.
- Если встретили букву или цифру (`w`) и это первое слово в этой команде, то переходим в состояние `VW`.
- Любой другой символ - переходим в состояние `RW`, не записываем в `buffer` этот символ, продолжаем чтение с него же.

#### Состояние `VW`:
- Если встретили букву или цифру (`w`), то остаёмся в этом же состоянии.
- Символ `=` - записываем в `name` символ `=`, добавляем в `args` строку `buffer`, потом строку из всего, что после текущего символа, завершаем разбор текущей команды.
- Любой другой символ - переходим в состояние `RW`, не записываем в `buffer` этот символ, продолжаем чтение с него же.

#### Состояние `RW`:
- Если встретили пробельный символ, то если это первое слово, то в `name` записываем `buffer`, иначе добавляем в `args` строку `buffer`.
В любом случае отчищаем `buffer`, переходим в состояние `Empty`.
- Символ `'` - не добавляем в `buffer`, переход в `SQ`.
- Символ `"` - не добавляем в `buffer`, переход в `DQ`.
- Символ `\` - не добавляем в `buffer`, переход в `BS`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `SQ`.
- Если встретили символ `'`, не добавляем его в `buffer`, переходим в `RW`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `DQ`.
- Если встретили символ `"`, то не добавляем его в `buffer`, переходим в `RW`.
- Символ `\` - не добавляем в `buffer`, переход в `BS & DQ`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `BS`.
- Любой символ - переходим в `RW`.

#### Состояние `BS & DQ`.
- Любой символ - переходим в `DQ`.

#### Конечные состояния (когда прочитали весь всю строку):
- `RW` - Совершаем действие, как если бы встретили пробельный символ.
- `Empty` - заканчиваем разбор команды.

Если строка закончилась в любом другом состоянии, то !ошибка разбиения на команды!.

### 1.4. Выполнение команд

#### Иерархия команд

![](./cmdDiagram.svg)

Все команды, поддерживающиеся интерпретатором, бывают либо внутренними, которые наследуются от виртуального класса `Cmd`, либо внешними. Реализация любой внешней команды находится в классе `ExtCmd`. Оба этих класса наследуются от чисто виртуального класса `BaseCmd`. 

В этом базовом классе есть виртуальный метод `run`, который переопределяется классами наследниками. Каждая исполняемая команда наследуется `Cmd`. Поведение команды реализуется в переопределении виртуального метода `run`. В качестве аргументов `run` принимает непосредственно сами аргументы команды интерпретатора, введенные пользователем, в виде `vector<string>` и ссылку на текущее состояние окружения. Также в аргументах есть ссылки на потоки ввода,  вывода и вывода ошибок, с которыми будет взаимодействовать команда (подробнее см. ниже). 

При расширении поведения работы программы новой командой разработчику следует реализовать наследника `Cmd`, и добавить ее в специальный `hash_map<string, shared_ptr<BaseCmd>>`, где ключ - имя команды, значение - указатель на объект с реализацией поведения команды в коде программы.

#### Вызов команд

Выполнение команд - последовательное исполнение каждого `job` из вектора, полученного из парсера, соответствующим полиморфным объектом наследником `BaseCmd`. Команды в пайплайне выполняются последовательно, порядок выполнения соответствует порядку команд в пайплайне. Следующая команда начнет выполняться только после завершения предыдущей.

Исполнение `job` - поиск соответствующей реализации команды по ее имени в `hash_map<string, shared_ptr<BaseCmd>>` и ее исполнение на аргументах из `job`. Если соответствующая команда не была найдена среди внутренних, то выполняется поиск внешней программы по ее имени в текущем `PATH` и выполнение этой программы. 

- Каждая команда после исполнения возвращает свой код возврата в виде `int`. Если был возвращен `0`, то команда была выполнена без ошибок. В обратном случае команда вернет `1`.

- Если не было найдено ни внутренней команды, ни внешней программы, то !ошибка исполнения команды - неизвестная команда!.

- Если для внутренних команд было передано некорректное количество аргументов, то !ошибка исполнения команды - некорректное количество аргументов!.

#### Механизм передачи потоков ввода-вывода

Каждой команде при вызове ее метода `run` помимо ссылки на текущее состояние окружения и пользовательских аргументов передается ссылка на ее поток ввода `istream&`, поток вывода `ostream&`, с которыми она и будет взаимодействовать. 

- Если пользователь ввел одну команду без пайплайнов, то, в случае ее корректности и существования среди исполняемых, ей будут переданы ссылки на потоки, которые были переданы интерпретатору при запуске. По умолчанию они инициализируются стандартными потоками `stdin`, `stdout` и `stderr`.

- Если пользователь ввел последовательность команд в пайплайне, то механизм перенаправления потоков ввода-вывода следующий: 

  Первая исполняемая команда из пайплайна в качестве `istream&` принимает глобальный поток ввода всего интерпретатора (по умолчанию `stdin`), а в качестве `ostream&` ссылку на `stringstream`, созданный до вызова `run` команды. Этот `stringstream` после исполнения текущей команды будет передан следующей команде из пайплайна в качестве `istream&`. При этом ее `ostream&` - новый `stringstream`, созданный между вызовом текущей команды и следующей. Т.е. для каждой команды пайплайна будет создан ее поток вывода, который будет передан следующей команде в качестве потока ввода. 
  
  Последняя команда в качестве `ostream&` всегда получает ссылку на глобальный поток вывода интерпретатора (по умолчанию `stdout`). В качестве потока вывода ошибок все команды получают глобальный поток вывода ошибок интерпретатора (по умолчанию `stderr`).
  
  Пример: пусть в текущей директории есть исполняемые файлы `foo` и `bar`. Интерпретатор запущен с потоками ввода-вывода по умолчанию.
  
  `foo` содержит в себе одну строчку `Hello, bash!`. `bar` после запуска считывает из ввода все числа, игнорируя слова, состоящие из других символов, складывает эти числа и выводит результат в консоль. Тогда результат работы wc `1  2 13 foo` будет записан в поток вывода этой команды. Команда `bar` получит этот поток в качестве потока ввода, прочитает его, и выведет число `16`:
  
  ```sh
  > wc foo | bar
  16
  ```

- Если при выполнении последовательности команд из пайплайна произошла ошибка, то информация об этой ошибке выводится в глобальный поток вывода интерпретатора, а сама команда ничего не выведет в свой поток вывода.

- После выполнения одиночной команды либо пайплайна команд программа выведет новое приглашение пользователя на ввод `> `.

## 2. Список поддерживаемых команд

### 2.1. Наследники `Cmd`

#### 2.1.1. `cat <FILE>...`

Конкатенирует файлы и выводит результат в поток вывода. \
Выводит файлы последовательно, если какого-то из файлов нет, то выводится сообщение об ошибке и обработка продолжается.

Возможные ошибки:
1. Переданные файлы не найдены - ошибка `example_file: No such file or directory`.
2. Файл нельзя открыть для чтения - ошибка `example_file: Permission denied`.

Подробнее о типах ошибок см. внизу.

Пример:
  ```sh
  > cat text.txt txet.txt
  some text from file 1
  txet.txt: no such file or directory
  ```

#### 2.1.2. `echo <ARG>...`

Выводит все аргументы в виде как строк.

Пример:
  ```sh
  > echo exit from text.txt
  exit from text.txt
  ```
  
#### 2.1.3. `wc <FILE>...`

Отображает количество строк, слов и байт в файле. \
Принимает в качестве аргументов одно и более имен файлов. Если файлов несколько, то помимо статистики для каждого файла, в последней строке отображает суммарную информацию по всем переданным файлам. 

Возможные ошибки: 
1. Не было передано ни одного файла - ошибка `No files were provided`
2. Переданные файлы не найдены - ошибка `example_file: No such file or directory`
3. Файл нельзя открыть для чтения - ошибка `example_file: Permission denied`

Пример:
  ```sh
  > wc abc file1.txt fil.txt
  abc: no such file or directory
  10 22 305 file1.txt
  fil.txt: no such file or directory
  10 22 305 total
  ```

#### 2.1.4. `pwd`

Отображает полное имя текущей директории. \
Если переданы дополнительные аргументы, то они игнорируются.

Пример:
  ```sh
  > pwd abc abd
  /home/username/some_directory
  ```

#### 2.1.5. `exit`

Вызывает нормальное завершение.\
Если переданы дополнительные аргументы, они игнорируются. Если команда `exit` будет внутри пайплайна команда, то интерпретатор завершит выполнение сразу, как только выполнит эту команду, т.е. команды, следующие после `exit` в этом пайплайне выполняться не будут.

#### 2.1.6. Присваивание `=`

Выполняет присваивание переменной с именем своего первого аргумента значение своего второго аргумента в виде строки.

Возможные ошибки:
1. Количество аргументов больше 2 - ошибка `Wrong number of arguments`.

Пример:
  ```sh
  > foo=hello
  > echo $foo, world
  hello, world
  ```
### 2.2. `ExtCmd`

При вызове внешней программы будет создан синхронный дочерний процесс, которому будут переданы текущие потоки ввода-вывода команды, а также словарь, в котором будут перечислены текущие переменные окружения.

При окончании работы внешней программы возобновится выполнение интерпретатора. Кодом возврата выполнения команды будет код возврата внешней программы.

Возможные ошибки:
1. Внешняя программа завершилась с ошибкой - Критическая ошибка `External programm error`

## Состояние окружения

Следующие сущности представляют собой текущее состояние окружения:
1. Текущий `PATH`.
2. Переменные окружения в виде `hash_map<string, string>`, где ключ - имя переменной, значение - значение переменной.
3. Код возврата последней исполненной команды. Коды возврата команд из пайплайна сохраняются, но переписываются кодом возврата следующей. Т.е. после выполнения пайплайна команд будет сохранен код возврата последней команды из пайплайна.

## Обработка ошибок

- Ошибки, возникшие на этапах лексической обработки и парсинга останавливают выполнение текущей последовательности команд, выводится информация об ошибке и новое приглашение пользователя на ввод `> `.
- При возникновении ошибок во время выполнения команд в глобальный вывод выведется информация об ошибке. В таком случае команда или пайплайн команд все равно отработают до конца, но возможно без каких либо эффектов.

# Фаза 1 

Реализация интерпретатора без пайпов и подстановок. Все команды являются одиночными.

# Фаза 2

Полная реализация вышеописанного интерпретатора.
