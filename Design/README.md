# CLI bash-like интерпретатор

Программа представляет собой интерпретатор командной строки. Интерпретатор построчно до символа новой строки считывает команды пользователя и выполняет их. Программа работает с графическими символами ASCII. При использовании программы с символами из других кодировок ее поведение не определено.  

Подробнее о командах, введенных пользователем, и примерах их использования см. ниже. 

Потоки ввода-вывода всей программы задаются в ее аргументах при запуске. Если они не заданы, то потоки ввода-вывода берутся по умолчанию: `stdin`, `stdout`, `stderr`. 

## 1. Главный цикл

[Картинка с конечным автоматом цикла]

Основной принцип работы программы построен на главном цикле, состоящем из следующих этапов:
1. Ввод пользователем строки с командами.
2. Лексическая обработка - обработка одинарных и двойных кавычек, разбиение пайплайна на последовательность команд, подстановка переменных.
3. Парсинг - разбиение каждой команды на слова.
4. Выполнение команд. 

_Команда_ - введенная пользователем строка, разделенная пайпами. У команды есть ее имя и аргументы, представляющие собой строки. Что является пайпом, а что просто символом `|` см. ниже в описании этапа лексической обработки. 

Определение термина _слово_ см. в описании этапа парсинга.

### 1.1. Ввод строки пользователя
1. Вывод приглашения пользователя на ввод `> `.
2. Считывание строки символов до символа переноса строки.

### 1.2. Lexer - разделение ввода по символам `|` и осуществление подстановок

Подстановка: `$имя_переменной`, где `имя_переменной` - `w+` (непустая последовательность букв (по умолчанию латинский алфавит) или цифр).

`input`: `string` - строка (ввод пользователя) \
`output`: `vector<string>` - вектор строк (каждая строка отдельная команда, вместе - последовательность команд).

Lexer последовательно проходит по `input`, записывает пройденные символы в `buffer` - текущая прочитанная строка.

#### Состояния Lexer'а: 

[Картинка с конечным автоматом лексера]

- `Start`, начальное состояние;
- `Single quote (SQ)`, открыта одинарная кавычка;
- `Double quote (DQ)`, открыта двойная кавычка;
- `BS`, предыдущий символ `\` - символ экранирования (любой другой символ после него теряет свой синтаксический смысл).
- `Dollar`, началась подстановка;
- `Dollar in Double quote (Dollar & DQ)`, началась подстановка внутри двойных кавычек;
- `BS in Double quote (BS & DQ)`, предыдущий символ `\` в двойных кавычках.

#### Состояние `Start`.
- Если встретили '|', то совершаем следующее действие: добавляем `buffer` в `output` (без `|`), очищаем `buffer`, остаёмся в этом же состоянии.
- Символ `'` - переход в `SQ`.
- Символ `"` - переход в `DQ`.
- Символ `\` - переход в `BS`.
- Символ `$` - переход в `Dollar`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `SQ`.
- Если встретили символ `'`, то переходим в `Start`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `DQ`.
- Если встретили символ `"`, то переходим в `Start`.
- Символ `$` - переход в `Dollar & DQ`.
- Символ `\` - переход в `BS & DQ`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `BS`.
- Любой символ - переходим в `Start`.

#### Состояние `Dollar`.
В этом состоянии записываем пройденные символы не в `buffer`, а в `var` (`$` никуда не записываем).
- Если встретили `w` (буква или цифра) - остаёмся в этом же состоянии.
- Любой другой символ - если `var` пустая строка, то записываем в `buffer` символ `$`, иначе записываем в `buffer` строку `varEnv[var]` (значение переменной `var` хранящееся в окружении; операцией присваивания должно гарантироваться, что в этом значении все символы, имеющие синтаксический смысл, экранированы символом `\`), очищаем `var`. 
В любом случае после этих действий переходим в `Start`, при этом продолжаем чтение с того же символа (не двигаемся по `input`).

#### Состояние `Dollar & DQ`.
Это состояние аналогично состоянию `Dollar`, только переходим не в `Start`, а в `DQ`.

#### Состояние `BS & DQ`.
Это состояние аналогично состоянию `BS`, только переходим не в `Start`, а в `DQ`.

#### Конечных состояний два (когда прочитали весь `input`):
- `Start` - добавляем `buffer` в `output`, возвращаем `output`.
- `Dollar` - совершаем действие, как если бы встретили любой символ кроме `w`.

Если строка закончилась в любом другом состоянии, то !ошибка разбиения по `|`!.

Пример валидного `input`: \
`   ` \
`echo a` \
`echo '"' | echo b "'"` \
`echo \| | echo \'` \

Пример невалидного `input`: \
`echo "a | echo b` \
`echo 'abc` \
`echo \`

### 1.3. Parser - разбиение команды на слова

[Картинка с конечным автоматом парсера]

Слово - это последовательность непробельных символов (`s`), или последовательность символов, заключённых в кавычки, или экранированный пробельный символ (`\ `), или комбинация этих последовательностей (кавычки удаляются из строки). 
Первое слово - имя команды, следующие - её аргументы. 
За исключением команды присваивания, которая имеет вид `w+=*`, имя команды в таком случае - это символ `=`, первый аргумент `w+` (последовательность букв или цифр левее `=`, имя переменной), второй аргумент `*` (всё, что правее `=`, значение переменной).

`input` - `vector<string>` - вектор строк (команд). \
`output` - `vector` структур `msg` с полями: `string name` - имя команды, `vector<string> args` - аргументы команды.

Parser последовательно проходится по каждой строке `input` и записывает пройденные символы в `buffer`.

#### Состояния Parser'а:
- `Empty` - начальное состояние, слово ещё не началось.
- `Var word (VW)` - началось слово, которое может быть именем переменной.
- `Regular word (RW)` - началось обычное слово.
- `Single quote (SQ)` - открыта одинарная кавычка.
- `Double quote (DQ)` - открыта двойная кавычка.
- `BS` - предыдущий символ `\`.
- `BS in Double quote (BS & DQ)` - предыдущий символ `\` в двойных кавычках.

#### Состояние `Empty`:
- Если встретили пробельный символ (`s`), то остаёмся в этом же состоянии, не записываем в `buffer` этот символ.
- Если встретили букву или цифру (`w`) и это первое слово в этой команде, то переходим в состояние `VW`.
- Любой другой символ - переходим в состояние `RW`.

#### Состояние `VW`:
- Если встретили букву или цифру (`w`), то остаёмся в этом же состоянии.
- Символ `=` - записываем в `name` символ `=`, добавляем в `args` строку `buffer`, потом строку из всего, что после текущего символа, завершаем разбор текущей команды.
- Любой другой символ - переходим в состояние `RW`, не записываем в `buffer` этот символ, продолжаем чтение с него же.

#### Состояние `RW`:
- Если встретили пробельный символ, то если это первое слово, то в `name` записываем `buffer`, иначе добавляем в `args` строку `buffer`.
В любом случае отчищаем `buffer`, переходим в состояние `Empty`.
- Символ `'` - не добавляем в `buffer`, переход в `SQ`.
- Символ `"` - не добавляем в `buffer`, переход в `DQ`.
- Символ `\` - не добавляем в `buffer`, переход в `BS`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `SQ`.
- Если встретили символ `'`, не добавляем его в `buffer`, переходим в `RW`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `DQ`.
- Если встретили символ `"`, то не добавляем его в `buffer`, переходим в `RW`.
- Символ `\` - не добавляем в `buffer`, переход в `BS & DQ`.
- Любой другой символ - остаёмся в этом же состоянии.

#### Состояние `BS`.
- Любой символ - переходим в `RW`.

#### Состояние `BS & DQ`.
- Любой символ - переходим в `DQ`.

#### Конечные состояния (когда прочитали весь всю строку):
- `RW` - Совершаем действие, как если бы встретили пробельный символ.
- `Empty` - заканчиваем разбор команды.

Если строка закончилась в любом другом состоянии, то !ошибка разбиения на команды!.

### 1.4. Выполнение команд

#### Иерархия команд

[Картинка с иерархией команд: BaseCmd, у него 3 наследника]

Все команды, поддерживающиеся интерпретатором, можно разделить на 3 группы:
1. `PureCmd` - внутренние обычные команды, которые не изменяют окружение.
2. `MutCmd` - внутренние специальные команды, которые меняют окружение.
3. `ExtCmd` - команды, вызывающие внешние программы.

Каждая группа представляет собой класс, которые наследуются от общего абстрактного класса `BaseCmd`. В этом базовом классе есть виртуальный метод `run`, который переопределяется классами наследниками. Каждая исполняемая команда наследуется от одного из трех вышеперечисленных классов команд в соответствии со своим семантическим поведением. Поведение команды реализуется в переопределении виртуального метода `run`. В качестве аргументов `run` принимает непосредственно сами аргументы `vector<string>`, введенные пользователем, ссылку на текущее состояние окружения, которая для наследников `PueCmd` является константной `const&`. Также в аргументах есть ссылки на потоки ввода,  вывода и вывода ошибок, с которыми будет взаимодействовать команда (подробнее см. ниже). 

При расширении поведения работы программы новой командой разработчику следует реализовать наследника одного из трех типов исполняемых команд, соответствующего поведению добавляемой команды, и добавить ее в специальный `unordered_map<string, shared_ptr<BaseCmd>>`, где ключ - имя команды, значение - указатель на объект с реализацией поведения команды в коде программы.

#### Вызов команд

Выполнение команд - последовательное исполнение каждого `msg` из вектора, полученного из парсера, соответствующим полиморфным объектом наследником `BaseCmd`.

Исполнение `msg` - поиск соответствующей реализации команды по ее имени в `unordered_map<string, shared_ptr<BaseCmd>>` и ее исполнение на аргументах из `msg`. Если соответствующая команда не была найдена среди внутренних, то выполняется поиск внешней программы по ее имени в текущем `PATH` и выполнение этой программы. 

- Если не было найдено ни внутренней команды, ни внешней программы, то !ошибка исполнения команды - неизвестная команда!.

- Если для внутренних команд было передано некорректное количество аргументов, то !ошибка исполнения команды - некорректное количество аргументов!.

#### Механизм передачи потоков ввода-вывода

[Конечный автомат с передачей потоков ввода-вывода]

Каждой команде при вызове ее метода `run` помимо ссылки на текущее состояние окружения и пользовательских аргументов передается ссылка на ее поток ввода `istream&`, поток вывода `ostream&`, с которыми она и будет взаимодействовать. 

- Если пользователь ввел одну команду без пайплайнов, то, в случае ее корректности и существования среди исполняемых, ей будут переданы ссылки на потоки, которые были переданы интерпретатору при запуске. По умолчанию они инициализируются стандартными потоками `stdin`, `stdout` и `stderr`.

- Если пользователь ввел последовательность команд в пайплайне, то механизм перенаправления потоков ввода-вывода следующий: 

  Первая исполняемая команда из пайплайна в качестве `istream&` принимает глобальный поток ввода всего интерпретатора (по умолчанию `stdin`), а в качестве `ostream&` ссылку на `stringstream`, созданный до вызова `run` команды. Этот `stringstream` после исполнения текущей команды будет передан следующей команде из пайплайна в качестве `istream&`. При этом ее `ostream&` - новый `stringstream`, созданный между вызовом текущей команды и следующей. Т.е. для каждой команды пайплайна будет создан ее поток вывода, который будет передан следующей команде в качестве потока ввода. 
  
  Последняя команда в качестве `ostream&` всегда получает ссылку на глобальный поток вывода интерпретатора (по умолчанию `stdout`). В качестве потока вывода ошибок все команды получают глобальный поток вывода ошибок интерпретатора (по умолчанию `stderr`).

# Фаза 1 

Лексер не обрабатывает пайпы `|`, считает что в полученной строке только одна команда. \
Подстановки и операция присваивания не обрабатываются, выполняются только именные внутренние команды и вызываются внешние программы.

# Фаза 2

Полная функциональность в соответствии с ТЗ.
